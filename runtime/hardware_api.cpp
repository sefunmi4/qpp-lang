#include "hardware_api.h"
#include <iostream>
#include <sstream>

namespace qpp {

static std::unique_ptr<QPUBackend> active_backend;

void set_qpu_backend(std::unique_ptr<QPUBackend> b) {
    active_backend = std::move(b);
}

QPUBackend* qpu_backend() { return active_backend.get(); }

std::string emit_qir(const std::vector<std::vector<std::string>>& ops) {
    std::ostringstream out;
    out << "; QIR v0 generated by qpp-run\n";
    out << "define void @main() {\n";
    for (const auto& ins : ops) {
        if (ins.empty()) continue;
        const std::string& op = ins[0];
        if (op == "H" || op == "X" || op == "Y" || op == "Z" || op == "S" || op == "T") {
            out << "  call void @__quantum__qis__" << op << "(i64 " << ins[2] << ") ;\n";
        } else if (op == "CNOT") {
            out << "  call void @__quantum__qis__cnot(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CZ") {
            out << "  call void @__quantum__qis__cz(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CCX") {
            out << "  call void @__quantum__qis__ccx(i64 " << ins[2] << ", i64 " << ins[4] << ", i64 " << ins[6] << ") ;\n";
        } else if (op == "MEASURE") {
            out << "  %tmp" << ins[2] << " = call i1 @__quantum__qis__measure(i64 " << ins[2] << ") ;\n";
        }
    }
    out << "  ret void\n";
    out << "}\n";
    return out.str();
}

} // namespace qpp
