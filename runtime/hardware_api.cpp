#include "hardware_api.h"
#include "logger.h"
#include <sstream>
#include <cstdio>
#include <unistd.h>

namespace qpp {

static std::unique_ptr<QPUBackend> active_backend;

static void invoke_python_backend(const std::string& script,
                                  const std::string& qir,
                                  const std::string& name) {
    char qir_path[] = "/tmp/qpp_qirXXXXXX";
    int fd = mkstemp(qir_path);
    if (fd == -1) {
        LOG_ERROR("Failed to create temp file for QIR");
        return;
    }
    FILE* f = fdopen(fd, "w");
    if (!f) {
        LOG_ERROR("fdopen failed");
        close(fd);
        return;
    }
    fwrite(qir.c_str(), 1, qir.size(), f);
    fclose(f);
    std::string cmd = std::string("python3 ") + script + " " + qir_path;
    int rc = std::system(cmd.c_str());
    if (rc != 0)
        LOG_ERROR(name, " backend execution failed");
    std::remove(qir_path);
}

void set_qpu_backend(std::unique_ptr<QPUBackend> b) {
    active_backend = std::move(b);
}

QPUBackend* qpu_backend() { return active_backend.get(); }

void QiskitBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/qiskit_backend.py", qir, "Qiskit");
}
  
void CirqBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/cirq_backend.py", qir, "Cirq");
}

void NvidiaBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/nvidia_backend.py", qir, "Nvidia");
}

void QSharpBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/qsharp_backend.py", qir, "QSharp");
}

void BraketBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/braket_backend.py", qir, "Braket");
}

void PsiBackend::execute_qir(const std::string& qir) {
    invoke_python_backend("../tools/psi_backend.py", qir, "PsiQuantum");
}

std::string emit_qir(const std::vector<std::vector<std::string>>& ops) {
    std::ostringstream out;
    out << "; QIR v0 generated by qpp-run\n";
    out << "define void @main() {\n";
    for (const auto& ins : ops) {
        if (ins.empty()) continue;
        const std::string& op = ins[0];
        if (op == "H" || op == "X" || op == "Y" || op == "Z" || op == "S" || op == "T") {
            out << "  call void @__quantum__qis__" << op << "(i64 " << ins[2] << ") ;\n";
        } else if (op == "CNOT") {
            out << "  call void @__quantum__qis__cnot(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CZ") {
            out << "  call void @__quantum__qis__cz(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CCX") {
            out << "  call void @__quantum__qis__ccx(i64 " << ins[2] << ", i64 " << ins[4] << ", i64 " << ins[6] << ") ;\n";
        } else if (op == "QFT2") {
            out << "  ; QFT2 optimized stub\n";
        } else if (op == "GROVER2") {
            out << "  ; GROVER2 optimized stub\n";
        } else if (op == "MEASURE") {
            out << "  %tmp" << ins[2] << " = call i1 @__quantum__qis__measure(i64 " << ins[2] << ") ;\n";
        }
    }
    out << "  ret void\n";
    out << "}\n";
    return out.str();
}

} // namespace qpp
