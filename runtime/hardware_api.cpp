#include "hardware_api.h"
#include <iostream>
#include <sstream>
#include <cstdio>
#include <unistd.h>

namespace qpp {

static std::unique_ptr<QPUBackend> active_backend;

void set_qpu_backend(std::unique_ptr<QPUBackend> b) {
    active_backend = std::move(b);
}

QPUBackend* qpu_backend() { return active_backend.get(); }

void QiskitBackend::execute_qir(const std::string& qir) {
    // Write QIR to temporary file and invoke helper python script
    char qir_path[] = "/tmp/qpp_qirXXXXXX";
    int fd = mkstemp(qir_path);
    if (fd == -1) {
        std::cerr << "Failed to create temp file for QIR\n";
        return;
    }
    FILE* f = fdopen(fd, "w");
    if (!f) {
        std::cerr << "fdopen failed\n";
        close(fd);
        return;
    }
    fwrite(qir.c_str(), 1, qir.size(), f);
    fclose(f);
    std::string cmd = std::string("python3 ") + "../tools/qiskit_backend.py " + qir_path;
    int rc = std::system(cmd.c_str());
    if (rc != 0)
        std::cerr << "Qiskit backend execution failed\n";
    std::remove(qir_path);
}
  
void CirqBackend::execute_qir(const std::string& qir) {
    std::cout << "[Cirq] Received QIR:\n" << qir << std::endl;
}

void NvidiaBackend::execute_qir(const std::string& qir) {
    std::cout << "[Nvidia] Received QIR:\n" << qir << std::endl;
}

void QSharpBackend::execute_qir(const std::string& qir) {
    std::cout << "[QSharp] Received QIR:\n" << qir << std::endl;
}

void BraketBackend::execute_qir(const std::string& qir) {
    std::cout << "[Braket] Received QIR:\n" << qir << std::endl;
}

void PsiBackend::execute_qir(const std::string& qir) {
    std::cout << "[PsiQuantum] Received QIR:\n" << qir << std::endl;
}

std::string emit_qir(const std::vector<std::vector<std::string>>& ops) {
    std::ostringstream out;
    out << "; QIR v0 generated by qpp-run\n";
    out << "define void @main() {\n";
    for (const auto& ins : ops) {
        if (ins.empty()) continue;
        const std::string& op = ins[0];
        if (op == "H" || op == "X" || op == "Y" || op == "Z" || op == "S" || op == "T") {
            out << "  call void @__quantum__qis__" << op << "(i64 " << ins[2] << ") ;\n";
        } else if (op == "CNOT") {
            out << "  call void @__quantum__qis__cnot(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CZ") {
            out << "  call void @__quantum__qis__cz(i64 " << ins[2] << ", i64 " << ins[4] << ") ;\n";
        } else if (op == "CCX") {
            out << "  call void @__quantum__qis__ccx(i64 " << ins[2] << ", i64 " << ins[4] << ", i64 " << ins[6] << ") ;\n";
        } else if (op == "MEASURE") {
            out << "  %tmp" << ins[2] << " = call i1 @__quantum__qis__measure(i64 " << ins[2] << ") ;\n";
        }
    }
    out << "  ret void\n";
    out << "}\n";
    return out.str();
}

} // namespace qpp
